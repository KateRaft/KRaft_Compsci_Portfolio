#include "helpers.h"
#include <math.h>

// Convert image to grayscale
// Find each pixel value
// Calculate the average pixel value
// Set each color value to the average value
void grayscale(int height, int width, RGBTRIPLE image[height][width])
{
    // Find each pixel value; r = row, c = column
    for (int r = 0; r < height; r++)
    {
        for (int c = 0; c < width; c++)
        {
            // Calculate average pixel value of red, green and blue values
            float average = (image[r][c].rgbtRed + image[r][c].rgbtGreen + image[r][c].rgbtBlue) / 3.00;

            // Round average
            average = round(average);

            // Set each color value to the average value
            image[r][c].rgbtRed = average;
            image[r][c].rgbtGreen = average;
            image[r][c].rgbtBlue = average;

            // Set acceptable range for color values of pixels
            if (average > 255)
            {
                average = 255;
            }
        }
    }
    return;
}


// Convert image to sepia
// Calculate each new color value using the Sepia formula
// Ensure the result is an integer between 0 and 255 inclusive
void sepia(int height, int width, RGBTRIPLE image[height][width])
{
    // Find each pixel value; r = row, c = column
    for (int r = 0; r < height; r++)
    {
        for (int c = 0; c < width; c++)
        {
            // Find values of each pixel
            int originalRed = image[r][c].rgbtRed;
            int originalGreen = image[r][c].rgbtGreen;
            int originalBlue = image[r][c].rgbtBlue;

            // Calculate each new color value using the Sepia formula
            float sepiaRed = .393 * originalRed + .769 * originalGreen + .189 * originalBlue;
            float sepiaGreen = .349 * originalRed + .686 * originalGreen + .168 * originalBlue;
            float sepiaBlue = .272 * originalRed + .534 * originalGreen + .131 * originalBlue;

            // Round new color values
            sepiaRed = round(sepiaRed);
            sepiaGreen = round(sepiaGreen);
            sepiaBlue = round(sepiaBlue);

            // Set acceptable range for color values of pixels and set each color value to new color value generated by Sepia formula
            if (sepiaRed > 255)
            {
                image[r][c].rgbtRed = 255;
            }
            else
            {
                image[r][c].rgbtRed = sepiaRed;
            }

            if (sepiaGreen > 255)
            {
                image[r][c].rgbtGreen = 255;
            }
            else
            {
                image[r][c].rgbtGreen = sepiaGreen;
            }

            if (sepiaBlue > 255)
            {
                image[r][c].rgbtBlue = 255;
            }
            else
            {
                image[r][c].rgbtBlue = sepiaBlue;
            }
        }
    }
    return;
}


// Reflect image horizontally
// Swap pixels on horizontally opposite sides
void reflect(int height, int width, RGBTRIPLE image[height][width])
{
    // Find each pixel value; r = row, c = column
    for (int r = 0; r < height; r++)
    {
        for (int c = 0; c < width / 2; c++)
        {
            // Swap pixels on horizontally opposite sides
            RGBTRIPLE tmp = image[r][c];
            image[r][c] = image[r][width - c - 1];
            image[r][width - c - 1] = tmp;
        }
    }
    return;
}


// Blur image (box blur)

// Find each pixel value and store as RGBTRIPLE temporary variable; r = row, c = column
// Compute new value for pixels by taking average of the original color values of all of the pixels that form a grid around each pixel
// Compute new value for pixels by taking average of all pixels within one row and one column of the pixel
// Calculate average amount of green, average amount of blue, average amount of red across all pixels within one row and one column of pixel
// Round averages to nearest integer

void blur(int height, int width, RGBTRIPLE image[height][width])
{
    // Declare temporary array to store pixel values
    RGBTRIPLE tmp[height][width];

    // Declare variables to be used and initialize counters
    int r;
    int c;
    int h;
    int v;
    int totalPixels = 0;
    int totalRed = 0;
    int totalGreen = 0;
    int totalBlue = 0;

    // Find each pixel value in original array by iterating through rows and columns; r = row, c = column
    // Iterate through rows
    for (r = 0; r < height; r ++)
    {
        // Iterate through columns
        for (c = 0; c < width; c ++)
        {
            // Assign pixel values from original array to temporary array
            tmp[r][c] = image[r][c];

            // Compute new value for pixels by taking average of the original color values of all of the pixels that form a grid around each pixel including the pixel being blurred itself
            // Compute new value for pixels by taking average of all pixels within one row and one column of the pixel including the pixel being blurred itself
            // Calculate average amount of green, average amount of blue, average amount of red across all pixels within one row and one column of pixel

            // Iterate up, down, left, and right around pixel
            // Up and down = +/- v (vertical); left and right = +/- h (horizontal)
            // Assign pixel iteration methods according to location on grid (corners, edges, middle)
            // Locations to consider: top left corner, top right corner, bottom left corner, bottom right corner, top edge, bottom edge, left edge, right edge, middle

            // Iteration through top left corner pixel
            if (r == 0 && c == 0)
            {
                // Set vertical counter to 0 and increase until it hits the pixel within one column from starting pixel
                for (v = 0; v <= 1; v++)
                {
                    // Set horizontal counter to 0 and increase until it hits the pixel within one row from starting pixel
                    for (h = 0; h <= 1; h++)
                    {
                        // Add the total red from the pixels within one row and one column from original pixel to original pixel's red value
                        totalRed = totalRed + tmp[r][c].rgbtRed;

                        // Add the total green from the pixels within one row and one column from original pixel to original pixel's green value
                        totalGreen = totalGreen + tmp[r][c].rgbtGreen;

                        // Add the total blue from the pixels within one row and one column from original pixel to original pixel's blue value
                        totalBlue = totalBlue + tmp[r][c].rgbtBlue;

                        // Update total number of pixels every time a pixel is read
                        totalPixels ++;
                    }

                    // Calculate color value averages
                    float RedAverage = (totalRed / totalPixels);
                    float GreenAverage = (totalGreen / totalPixels);
                    float BlueAverage = (totalBlue / totalPixels);

                    // Round averages to nearest integer
                    RedAverage = round(RedAverage);
                    GreenAverage = round(GreenAverage);
                    BlueAverage = round(BlueAverage);

                    // Assign color averages to pixel in new array
                    tmp[r][c].rgbtRed = RedAverage;
                    tmp[r][c].rgbtGreen = GreenAverage;
                    tmp[r][c].rgbtBlue = BlueAverage;
                }
            }

            // Iteration through top right corner pixel
            if (r == 0 && c == (width - 1))
            {
                // Reset totalPixels counter to 0
                totalPixels = 0;

                // Set vertical counter to 0 and increase until it hits the pixel within one column from starting pixel
                for (v = 0; v <= 1; v++)
                {
                    // Set horizontal counter to 0 and increase until it hits the pixel within one row from starting pixel
                    for (h = (c - 1); h <= c; h++)
                    {
                        // Add the total red from the pixels within one row and one column from original pixel to original pixel's red value
                        totalRed = totalRed + tmp[r][c].rgbtRed;

                        // Add the total green from the pixels within one row and one column from original pixel to original pixel's green value
                        totalGreen = totalGreen + tmp[r][c].rgbtGreen;

                        // Add the total blue from the pixels within one row and one column from original pixel to original pixel's blue value
                        totalBlue = totalBlue + tmp[r][c].rgbtBlue;

                        // Update total number of pixels every time a pixel is read
                        totalPixels ++;
                    }

                    // Calculate color value averages
                    float RedAverage = (totalRed / totalPixels);
                    float GreenAverage = (totalGreen / totalPixels);
                    float BlueAverage = (totalBlue / totalPixels);

                    // Round averages to nearest integer
                    RedAverage = round(RedAverage);
                    GreenAverage = round(GreenAverage);
                    BlueAverage = round(BlueAverage);

                    // Assign color averages to pixel in new array
                    tmp[r][c].rgbtRed = RedAverage;
                    tmp[r][c].rgbtGreen = GreenAverage;
                    tmp[r][c].rgbtBlue = BlueAverage;
                }
            }

            // Iteration through bottom left corner pixel
            if (r == (height - 1) && c == 0)
            {
                // Reset totalPixels counter to 0
                totalPixels = 0;

                // Set vertical counter to 0 and increase until it hits the pixel within one column from starting pixel
                for (v = r - 1 - 1; v <= r - 1; v++)
                {
                    // Set horizontal counter to 0 and increase until it hits the pixel within one row from starting pixel
                    for (h = 0; h <= 1; h++)
                    {
                        // Add the total red from the pixels within one row and one column from original pixel to original pixel's red value
                        totalRed = totalRed + tmp[r][c].rgbtRed;

                        // Add the total green from the pixels within one row and one column from original pixel to original pixel's green value
                        totalGreen = totalGreen + tmp[r][c].rgbtGreen;

                        // Add the total blue from the pixels within one row and one column from original pixel to original pixel's blue value
                        totalBlue = totalBlue + tmp[r][c].rgbtBlue;

                        // Update total number of pixels every time a pixel is read
                        totalPixels ++;
                    }

                    // Calculate color value averages
                    float RedAverage = (totalRed / totalPixels);
                    float GreenAverage = (totalGreen / totalPixels);
                    float BlueAverage = (totalBlue / totalPixels);

                    // Round averages to nearest integer
                    RedAverage = round(RedAverage);
                    GreenAverage = round(GreenAverage);
                    BlueAverage = round(BlueAverage);

                    // Assign color averages to pixel in new array
                    tmp[r][c].rgbtRed = RedAverage;
                    tmp[r][c].rgbtGreen = GreenAverage;
                    tmp[r][c].rgbtBlue = BlueAverage;
                }
            }

            // Iteration through bottom right corner pixel
            if (r == (height - 1) && c == (width - 1))
            {
                // Reset totalPixels counter to 0
                totalPixels = 0;

                // Set vertical counter to 0 and increase until it hits the pixel within one column from starting pixel
                for (v = (r - 1); v <= r; v++)
                {
                    // Set horizontal counter to 0 and increase until it hits the pixel within one row from starting pixel
                    for (h = (c - 1); h <= c; h++)
                    {
                        // Add the total red from the pixels within one row and one column from original pixel to original pixel's red value
                        totalRed = totalRed + tmp[r][c].rgbtRed;

                        // Add the total green from the pixels within one row and one column from original pixel to original pixel's green value
                        totalGreen = totalGreen + tmp[r][c].rgbtGreen;

                        // Add the total blue from the pixels within one row and one column from original pixel to original pixel's blue value
                        totalBlue = totalBlue + tmp[r][c].rgbtBlue;

                        // Update total number of pixels every time a pixel is read
                        totalPixels ++;
                    }

                    // Calculate color value averages
                    float RedAverage = (totalRed / totalPixels);
                    float GreenAverage = (totalGreen / totalPixels);
                    float BlueAverage = (totalBlue / totalPixels);

                    // Round averages to nearest integer
                    RedAverage = round(RedAverage);
                    GreenAverage = round(GreenAverage);
                    BlueAverage = round(BlueAverage);

                    // Assign color averages to pixel in new array
                    tmp[r][c].rgbtRed = RedAverage;
                    tmp[r][c].rgbtGreen = GreenAverage;
                    tmp[r][c].rgbtBlue = BlueAverage;
                }
            }


            // Iteration through top edge pixels
            if ((r == 0) && (c >= 1) && (c <= width - 1 - 1))
            {
                // Reset totalPixels counter to 0
                totalPixels = 0;

                // Set vertical counter to 0 and increase until it hits the pixel within one column from starting pixel
                for (v = 0; v <= 1; v++)
                {
                    // Set horizontal counter to 0 and increase until it hits the pixel within one row from starting pixel
                    for (h = (c - 1); h <= (c + 1); h++)
                    {
                        // Add the total red from the pixels within one row and one column from original pixel to original pixel's red value
                        totalRed = totalRed + tmp[r][c].rgbtRed;

                        // Add the total green from the pixels within one row and one column from original pixel to original pixel's green value
                        totalGreen = totalGreen + tmp[r][c].rgbtGreen;

                        // Add the total blue from the pixels within one row and one column from original pixel to original pixel's blue value
                        totalBlue = totalBlue + tmp[r][c].rgbtBlue;

                        // Update total number of pixels every time a pixel is read
                        totalPixels ++;
                    }

                    // Calculate color value averages
                    float RedAverage = (totalRed / totalPixels);
                    float GreenAverage = (totalGreen / totalPixels);
                    float BlueAverage = (totalBlue / totalPixels);

                    // Round averages to nearest integer
                    RedAverage = round(RedAverage);
                    GreenAverage = round(GreenAverage);
                    BlueAverage = round(BlueAverage);

                    // Assign color averages to pixel in new array
                    tmp[r][c].rgbtRed = RedAverage;
                    tmp[r][c].rgbtGreen = GreenAverage;
                    tmp[r][c].rgbtBlue = BlueAverage;
                }
            }

            // Iteration through bottom edge pixels
            if ((r == height - 1) && (c >= 1) && (c <= width - 1 - 1))
            {
                // Reset totalPixels counter to 0
                totalPixels = 0;

                // Set vertical counter to 0 and increase until it hits the pixel within one column from starting pixel
                for (v = (r - 1); v <= r; v++)
                {
                    // Set horizontal counter to 0 and increase until it hits the pixel within one row from starting pixel
                    for (h = (c - 1); h <= (c + 1); h++)
                    {
                        // Add the total red from the pixels within one row and one column from original pixel to original pixel's red value
                        totalRed = totalRed + tmp[r][c].rgbtRed;

                        // Add the total green from the pixels within one row and one column from original pixel to original pixel's green value
                        totalGreen = totalGreen + tmp[r][c].rgbtGreen;

                        // Add the total blue from the pixels within one row and one column from original pixel to original pixel's blue value
                        totalBlue = totalBlue + tmp[r][c].rgbtBlue;

                        // Update total number of pixels every time a pixel is read
                        totalPixels ++;
                    }

                    // Calculate color value averages
                    float RedAverage = (totalRed / totalPixels);
                    float GreenAverage = (totalGreen / totalPixels);
                    float BlueAverage = (totalBlue / totalPixels);

                    // Round averages to nearest integer
                    RedAverage = round(RedAverage);
                    GreenAverage = round(GreenAverage);
                    BlueAverage = round(BlueAverage);

                    // Assign color averages to pixel in new array
                    tmp[r][c].rgbtRed = RedAverage;
                    tmp[r][c].rgbtGreen = GreenAverage;
                    tmp[r][c].rgbtBlue = BlueAverage;
                }
            }


            // Iteration through left edge pixels
            if ((r >= 1) && (r <= height - 1 - 1) && (c == 0))
            {
                // Reset totalPixels counter to 0
                totalPixels = 0;

                // Set vertical counter to 0 and increase until it hits the pixel within one column from starting pixel
                for (v = r - 1; v <= (r + 1); v++)
                {
                    // Set horizontal counter to 0 and increase until it hits the pixel within one row from starting pixel
                    for (h = 0; h <= 1; h++)
                    {
                        // Add the total red from the pixels within one row and one column from original pixel to original pixel's red value
                        totalRed = totalRed + tmp[r][c].rgbtRed;

                        // Add the total green from the pixels within one row and one column from original pixel to original pixel's green value
                        totalGreen = totalGreen + tmp[r][c].rgbtGreen;

                        // Add the total blue from the pixels within one row and one column from original pixel to original pixel's blue value
                        totalBlue = totalBlue + tmp[r][c].rgbtBlue;

                        // Update total number of pixels every time a pixel is read
                        totalPixels ++;
                    }

                    // Calculate color value averages
                    float RedAverage = (totalRed / totalPixels);
                    float GreenAverage = (totalGreen / totalPixels);
                    float BlueAverage = (totalBlue / totalPixels);

                    // Round averages to nearest integer
                    RedAverage = round(RedAverage);
                    GreenAverage = round(GreenAverage);
                    BlueAverage = round(BlueAverage);

                    // Assign color averages to pixel in new array
                    tmp[r][c].rgbtRed = RedAverage;
                    tmp[r][c].rgbtGreen = GreenAverage;
                    tmp[r][c].rgbtBlue = BlueAverage;
                }
            }


            // Iteration through right edge pixels
            if (r >= 1 && r <= (height - 1 - 1) && c == (width - 1))
            {
                // Reset totalPixels counter to 0
                totalPixels = 0;

                // Set vertical counter to 0 and increase until it hits the pixel within one column from starting pixel
                for (v = (r - 1); v <= (r + 1); v++)
                {
                    // Set horizontal counter to 0 and increase until it hits the pixel within one row from starting pixel
                    for (h = (c - 1); h <= c; h++)
                    {
                        // Add the total red from the pixels within one row and one column from original pixel to original pixel's red value
                        totalRed = totalRed + tmp[r][c].rgbtRed;

                        // Add the total green from the pixels within one row and one column from original pixel to original pixel's green value
                        totalGreen = totalGreen + tmp[r][c].rgbtGreen;

                        // Add the total blue from the pixels within one row and one column from original pixel to original pixel's blue value
                        totalBlue = totalBlue + tmp[r][c].rgbtBlue;

                        // Update total number of pixels every time a pixel is read
                        totalPixels ++;
                    }

                    // Calculate color value averages
                    float RedAverage = (totalRed / totalPixels);
                    float GreenAverage = (totalGreen / totalPixels);
                    float BlueAverage = (totalBlue / totalPixels);

                    // Round averages to nearest integer
                    RedAverage = round(RedAverage);
                    GreenAverage = round(GreenAverage);
                    BlueAverage = round(BlueAverage);

                    // Assign color averages to pixel in new array
                    tmp[r][c].rgbtRed = RedAverage;
                    tmp[r][c].rgbtGreen = GreenAverage;
                    tmp[r][c].rgbtBlue = BlueAverage;
                }
            }


            // Iteration through middle pixels
            if ((r >= 1) && (r <= height - 1 - 1) && (c >= 1) && (c <= width - 1 - 1))
            {
                // Reset totalPixels counter to 0
                totalPixels = 0;

                // Set vertical counter to 0 and increase until it hits the pixel within one column from starting pixel
                for (v = r - 1; v <= (r + 1); v++)
                {
                    // Set horizontal counter to 0 and increase until it hits the pixel within one row from starting pixel
                    for (h = (c - 1); h <= (c + 1); h++)
                    {
                        // Add the total red from the pixels within one row and one column from original pixel to original pixel's red value
                        totalRed = totalRed + tmp[r][c].rgbtRed;

                        // Add the total green from the pixels within one row and one column from original pixel to original pixel's green value
                        totalGreen = totalGreen + tmp[r][c].rgbtGreen;

                        // Add the total blue from the pixels within one row and one column from original pixel to original pixel's blue value
                        totalBlue = totalBlue + tmp[r][c].rgbtBlue;

                        // Update total number of pixels every time a pixel is read
                        totalPixels ++;
                    }

                    // Calculate color value averages
                    float RedAverage = (totalRed / totalPixels);
                    float GreenAverage = (totalGreen / totalPixels);
                    float BlueAverage = (totalBlue / totalPixels);

                    // Round averages to nearest integer
                    RedAverage = round(RedAverage);
                    GreenAverage = round(GreenAverage);
                    BlueAverage = round(BlueAverage);

                    // Assign color averages to pixel in new array
                    tmp[r][c].rgbtRed = RedAverage;
                    tmp[r][c].rgbtGreen = GreenAverage;
                    tmp[r][c].rgbtBlue = BlueAverage;
                }
            }
        }
    }

    // Transfer information from temporary array back to original array
    for (r = 0; r < height; r ++)
    {
        for (c = 0; c < width; c ++)
        {
            image[r][c] = tmp[r][c];
        }
    }
    return;
}
